
 -- Normalization basics

  # What's the NF we should aspire to?

  # How do design tables to meet this aspiration?
--------------------------------------------------------------------------------------

  # A couple of definitions to get started:

    -- Field, Attribute, Column: we'll use these interchangably. For example, in the table

            Employee(Id, FirstName, MiddleInit, LastName, Sal, JobCategory_Id)

       there are 6 'fields', 'attributes', or 'columns'.

    -- A 'candidate key' is any single column or collection of columns that is unique per row.

          Example: The customers table in the RecClub DB has a 'designated primary key',
	           which is thereby a 'candidate key' as well.

                   It so happens, because of the BuildTablesUtil program, that each customer
		   name is unique (e.g., Alice11, Alice23, Alice31). But the table structure
		   ('schema') does _not_ ensure unique name.

                   We could declare that the 'name' field is UNIQUE when creating the table.
	           In this case, the 'name' also would be a candidate key.

    -- A 'key' (or 'prime') field is (part of) a candidate key; other fields are 'non-key' ('non-prime').

    -- A candidate key can be a single field, two fields, three fields -- even all of the fields together.

    -- In SQL, the 'PRIMARY KEY' qualifier makes a candidate key an explicitly designated key, and the DB 
       system then ensures unique values for the key.

    -- It's possible, but not good practice, to have _only_ all of fields in a record together make up
       the one and only candidate key. 

    -- If you designate a single 'primary key' such as sess_id or act_id, you have a single-column
       candidate key -- and design life becomes simpler. :)

  # 1NF

    -- Consider this table design

      Employee(Id, Name,...)   ## a single Name field instead of: First Name, Middle Initial, Last Name fields

    and a sample entry

      Id            Name            ...
      27   Frederick J. Flintsone
         ...

    -- Suppose we need a query that gets only the last names of Employees. Given this table design we must:

       ## Query for the Name field, getting values such as 'Frederick J. Flintstone'

       ## Use a substring or equivalent operation to extract 'Flintstone' from this single field.

    -- In short, the Name field does not contain 'atomic' (irreducible) data values, but instead composite ones
       that must be broken out in an ad hoc fashion

    -- Summary: a table is 1NF if all of its columns contain 'atomic data values'.

    -- Fix for this table: 

       Replace Employee(Id, Name,...) with Employee(Id, FirstName, MiddleInit, LastName,...)
------------------------------------------------------------------------------------------------------------------------------

  # Candidate keys and functional dependencies

            autogenerated unique integer value         foreign key to JobCategory (Accounting, IT, etc.)
                       \                                        /
    Example:  Employee(Id, FirstName, MiddleInit, LastName, JobCategory_Id)
                               /          \          /           
                             text        text     text

    Assumptions: Each Id is guaranteed unique, but no other field (column) is so.
                 For example, two employees could have exactly the same name (Johanna J. Jones), 
                 and could belong to the same Category (Accounting). Their records would differ
                 only in the Id field.
 
    -- Because the Id is unique per row, given a particular Id (e.g., 7) we can find
       the corresponding FirstName, MiddleInit, LastName, and Category_Id.

        ## Id is a 'key' (or 'prime') field, and the other fields are 'non-key' (or 'non-prime').

        ## There is a 'functional dependency' of the other fields on Id, but no other functional dependencies:

                         determines
                 Id------------------------->FirstName, MiddleInit, LastName, JobCategory_Id
                          maps to            

                     FD
                 Id----->(FirstName, MiddleInit, LastName, JobCategory_Id) ## shorthand
                                              
           ### Given a particular Id (e.g., 7), we can find the First Name (Frederick),
               MiddleInit (J.), LastName (Flintsone), and Category_Id (18 for 'Driver') for each Employee.   
        
           ### Given, say, a LastName, we may not be be able to match up the corresponding fields because
               two or more employees might share a LastName.

     -- The flip side of 'functionally depends on' is 'functionally determines':

          Example:

               In the Employee table, the value of the LastName functionally depends on the value of the Id.
	       
	       In the Employee table, the value of the Id functionally determines the value of the LastName.

          In non-technical language, this means: given an Id value in a table, we can find a _single_ LastName
	  value from the Id.

  # 2NF (must be in 1NF and...)

       Table(Id1, Id2, A, B)
         Key: Id1-Id2         ## composite key -- consists of Id1 and Id2 together
         FDs: Id1----->A      ## 'partial key dependency': A depends only on Id1, not on the full key (a pair)
              Id2----->B      ## 'partial key dependency': B depends only on Id2, not on the full key (a pair)

         Fix: Id1-Id2----->A  ## 'full key' dependency
              Id1-Id2----->B  ## 'full key' dependency

  # 3NF (must be in 2NF and...)
     
      Table(Id, A, B)  
         Key: Id
         FDs: Id----->A
               A----->B    ## B depends 'transitively' on Id, but A depends _directly_ on Id

        Fix: Id----->A     ## A depends directly on Id
             Id----->B     ## B depends directly on Id

    -- To be in 2NF, a table must be in 1NF and meet further conditions.

    -- To be in 3NF, a table must be in 2NF and meet further conditions.

  # BCNF (Boyce-Code Normal Form) -- what we'll aim for

     BCNF differs from 3NF only when there are multiple overlapping candidate keys.
     We'll avoid this by having only single-field keys, and preferably just one: a designated primary key.

    If you have a single-column candidate key (e.g., an autogenerated integer value), then any table in 3NF is in BCNF.
    Here's a summary of what we'll aim for:

      -- Single-column candidate keys.

      -- Each non-key field (column, attribute) dependent directly on the key.

      -- No functional dependencies among the non-key fields.   

 




    

   


   
